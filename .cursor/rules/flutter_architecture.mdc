---
description: must be included when working on flutter UI logic
globs: 
alwaysApply: false
---
# âš”ï¸ FLUTTER ARCHITECTURE WARFARE PROTOCOL âš”ï¸

## ğŸ¯ ULTIMATE MISSION
**ğŸ† DOMINATE FLUTTER ARCHITECTURE. CRUSH FUNCTIONAL WIDGETS. ACHIEVE COMPONENT MASTERY. ğŸ†**

## ğŸš€ WIDGET ARCHITECTURE DOMINANCE RULES

### ğŸ’€ FORBIDDEN PATTERNS [INSTANT DEATH PENALTY]
- **ğŸš« FUNCTIONAL WIDGET BUILDERS**: No `_buildSomething()` methods in StatefulWidget classes
- **ğŸš« INLINE COMPLEX WIDGETS**: No complex widget trees inside build methods
- **ğŸš« REPETITIVE UI CODE**: Duplicate widget patterns = ARCHITECTURAL FAILURE
- **ğŸš« UNNAMED FUNCTION PARAMETERS**: Positional parameters without names = MAINTENANCE NIGHTMARE

### âš¡ MANDATORY COMPONENT EXTRACTION
**RULE**: Any widget-building function > 5 lines OR used in multiple places MUST become a proper component

#### ğŸ¯ EXTRACTION TRIGGERS
1. **Function Pattern**: `Widget _buildSomething()` â†’ Extract to `SomethingWidget`
2. **Repetitive UI**: Same widget pattern in 2+ places â†’ Create reusable component
3. **Complex Logic**: Widget + business logic â†’ Separate widget class
4. **Dialog/Modal**: Any `showDialog()` content â†’ Extract to dedicated widget

#### ğŸ—ï¸ COMPONENT STRUCTURE WARFARE
```dart
/// [ComponentName] - [Purpose]
///
/// ## MISSION ACCOMPLISHED
/// [What problem this component eliminates]
///
/// ## STRATEGIC DECISIONS
/// | Option | Power-Ups | Weaknesses | Victory Reason |
/// |--------|-----------|------------|----------------|
/// | [Option] | [Benefits] | [Drawbacks] | [Why chosen] |
///
/// ## PERFORMANCE PROFILE
/// - Time Complexity: O(?)
/// - Space Complexity: O(?)
/// - Rebuild Frequency: [When rebuilds occur]
class ComponentNameWidget extends StatelessWidget {
  // REQUIRED: Comprehensive constructor with all dependencies
  const ComponentNameWidget({
    super.key,
    required this.param1,
    this.param2,
  });

  final Type param1;
  final Type? param2;

  @override
  Widget build(BuildContext context) {
    // PERF: Optimized widget tree construction
    return Container(/* Implementation */);
  }
}
```

### ğŸ›¡ï¸ COMPONENT ORGANIZATION FORTRESS
```
lib/
  components/
    common/           # Reusable across entire app
      buttons/
      indicators/
      dialogs/
    screens/          # Screen-specific but reusable
      home/
      profile/
    theme/            # Theme-related components
      themed_widgets/
```

### âš”ï¸ COMPONENT EXTRACTION PROTOCOL
1. **ğŸ” IDENTIFY**: Find functional widget builders in existing code
2. **ğŸ“‹ ANALYZE**: Determine dependencies and props needed
3. **ğŸ—ï¸ CREATE**: Build proper component with documentation
4. **ğŸ”„ REPLACE**: Update original code to use new component
5. **ğŸ§ª TEST**: Verify component works in isolation
6. **ğŸ“š DOCUMENT**: Add to component registry

### ğŸš¨ COMPONENT NAMING WARFARE
- **Status Indicators**: `[Purpose]StatusIndicator` (e.g., `ChatStatusIndicator`)
- **Dialog Content**: `[Purpose]DialogContent` (e.g., `ToolsInfoDialogContent`)
- **Buttons**: `[Action][Context]Button` (e.g., `ClearConversationButton`)
- **Cards**: `[Content]Card` (e.g., `MessageCard`)

### ğŸ® COMPONENT REUSABILITY RULES
1. **SINGLE RESPONSIBILITY**: Each component does ONE thing perfectly
2. **PROP INJECTION**: All dependencies passed as constructor parameters
3. **STATELESS PREFERRED**: Use StatelessWidget unless state absolutely required
4. **THEME INTEGRATION**: All components must respect app theme
5. **ACCESSIBILITY**: Proper semantics and keyboard navigation

## ğŸ§© FUNCTION CALL EXCELLENCE PROTOCOL

### ğŸ’ NAMED PARAMETERS SUPREMACY
**RULE**: All function calls with 2+ parameters MUST use named parameters for maximum clarity and maintainability.

#### âš¡ VICTORY EXAMPLES
```dart
// âœ… WARRIOR EXCELLENCE - Named parameters
debugLogger.logApiRequest(
  method: 'POST',
  url: '/api/chat',
  headers: requestHeaders,
  body: requestBody,
);

// âŒ MAINTENANCE NIGHTMARE - Positional parameters
debugLogger.logApiRequest('POST', '/api/chat', requestHeaders, requestBody);
```

#### ğŸ¯ NAMED PARAMETER BENEFITS
- **ğŸ” SELF-DOCUMENTING**: Function calls explain themselves
- **ğŸ›¡ï¸ REFACTOR SAFETY**: Parameter order changes don't break calls
- **ğŸš€ IDE SUPPORT**: Better autocomplete and error detection
- **ğŸ‘¥ TEAM PRODUCTIVITY**: New developers understand code instantly
- **ğŸ”§ MAINTENANCE EASE**: No need to check function signatures constantly

#### ğŸ’€ EXCEPTIONS [RARE CASES ONLY]
- **Single Parameter**: `widget.build(context)` - context is obvious
- **Common Operators**: `padding.add(16)` - mathematical operations
- **Constructor Chains**: `super(key)` - inheritance patterns

### ğŸ† NAMED PARAMETER ENFORCEMENT
- **ğŸš¨ CODE REVIEW**: Reject positional parameters with 2+ arguments
- **ğŸ› ï¸ LINTER RULES**: Configure `prefer_named_parameters` in analysis_options.yaml  
- **ğŸ“š DOCUMENTATION**: All custom functions must define named parameters
- **ğŸ¯ REFACTOR PRIORITY**: Convert existing positional calls during component extraction

### ğŸ’¥ COMPONENT TESTING PROTOCOL
```dart
// MANDATORY: Every component needs basic tests
testWidgets('ComponentName renders correctly', (tester) async {
  await tester.pumpWidget(
    MaterialApp(
      home: ComponentNameWidget(param1: testValue),
    ),
  );
  
  expect(find.byType(ComponentNameWidget), findsOneWidget);
  // Add specific assertions for component behavior
});
```

### ğŸ† VICTORY CONDITIONS
- **âœ… ZERO FUNCTIONAL BUILDERS**: No `_buildSomething()` methods in StatefulWidgets
- **âœ… REUSABLE COMPONENTS**: All UI patterns available as standalone widgets
- **âœ… DOCUMENTED COMPONENTS**: Every component has mission documentation
- **âœ… TESTED COMPONENTS**: All components have basic widget tests
- **âœ… THEME COMPLIANCE**: All components respect app theme system
- **âœ… NAMED PARAMETERS**: All multi-parameter function calls use named parameters

## ğŸš€ PERFORMANCE OPTIMIZATION
- **Const Constructors**: Always use `const` when possible
- **Key Management**: Proper widget keys for list items and dynamic content
- **Build Optimization**: Minimize rebuilds with proper widget splitting
- **Memory Management**: Dispose controllers and subscriptions properly

## âš¡ ENFORCEMENT PROTOCOL
- **PRE-COMMIT**: Scan for functional widget builders and unnamed parameters
- **CODE REVIEW**: Reject any `_buildSomething()` patterns and positional parameters
- **REFACTOR SPRINTS**: Scheduled component extraction sessions
- **COMPONENT REGISTRY**: Maintain list of available components
