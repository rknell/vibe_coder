---
description: When a bug is reported, follow these steps in order to resolve it
globs: 
alwaysApply: false
---
# âš”ï¸ ELITE BUG FIXING WARRIOR PROTOCOL âš”ï¸

## ğŸ¯ ULTIMATE MISSION
**ğŸ† DOMINATE BUGS. CRUSH REGRESSIONS. ACHIEVE LEGENDARY STATUS. ğŸ†**

This document defines the mandatory bug-fixing protocol for VibeCoder following **Elite Warrior Standards** with zero tolerance for failing tests or linter errors.

## ğŸ’€ MANDATORY BUG FIXING STEPS [NO EXCEPTIONS]

### 1. âš”ï¸ REPRODUCE THE BUG [MANDATORY FIRST]
**RULE**: Every bug MUST be reproduced before any code changes.

#### ğŸ¯ REPRODUCTION REQUIREMENTS:
- Follow exact steps from bug report
- Use same data/environment conditions
- Document all reproduction steps
- Verify bug behavior matches report

#### ğŸš« BANNED PRACTICES:
- Blind fixes without reproduction
- Assumptions about bug behavior
- Skipping steps in reproduction

### 2. ğŸ§ª CREATE FAILING TEST [CRITICAL]
**RULE**: Write test BEFORE fixing the bug.

#### ğŸ¯ TEST REQUIREMENTS:
- Test MUST fail initially
- Test MUST be focused on ONLY this bug
- Test MUST be minimal and precise
- Test MUST follow user's reproduction steps
- Test MUST NOT modify existing tests unless flawed logic proven

#### ğŸ’» TEST IMPLEMENTATION:
```dart
// âœ… WARRIOR APPROVED: Focused bug test
test('ğŸ›¡ï¸ REGRESSION: Widget fails when data is null', () {
  final widget = MyWidget(data: null);
  expect(() => widget.build(context), throwsException);
});

// âŒ BANNED: Modifying existing tests without reason
test('existing test modified without justification', () {
  // CRIME: Changing working tests
});
```

### 3. ğŸ”§ IMPLEMENT FIX [SURGICAL PRECISION]
**RULE**: Write minimal code to make test pass.

#### ğŸ¯ FIX REQUIREMENTS:
- Follow architecture.mdc and flutter_architecture.mdc
- Implement cleanest solution
- Focus ONLY on this specific bug
- No unrelated changes

#### ğŸ’» FIX IMPLEMENTATION:
```dart
// âœ… WARRIOR APPROVED: Clean focused fix
class MyWidget extends StatelessWidget {
  final Data? data;
  
  @override
  Widget build(BuildContext context) {
    if (data == null) return Container(); // Clean null check
    return buildContent();
  }
}

// âŒ BANNED: Unfocused fixes
class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    try {
      // CRIME: Hiding errors instead of fixing root cause
      return buildContent();
    } catch (e) {
      return Container();
    }
  }
}
```

### 4. âœ… VERIFY FIX [ZERO TOLERANCE]
**RULE**: All tests MUST pass. No exceptions.

#### ğŸ¯ VERIFICATION REQUIREMENTS:
- New test passes
- All existing tests pass
- No linter errors
- No warnings
- Bug fix verified in same environment as reproduction

#### ğŸš« BANNED PRACTICES:
- Ignoring failing tests
- Suppressing linter errors
- Skipping test suite runs

### 5. ğŸ° SECURE THE FORTRESS [PERMANENT PROTECTION]
**RULE**: The regression test MUST be permanent.

#### ğŸ¯ PERMANENCE REQUIREMENTS:
- The new test created in Step 2 is committed to the codebase.
- The test is not a temporary diagnostic and provides permanent regression protection.
- Deleting regression tests is a critical violation of the **PERMANENT TEST FORTRESS PROTOCOL**.

## ğŸ† VICTORY CONDITIONS

### âœ… MANDATORY COMPLIANCE:
- [ ] Bug reproduced and documented
- [ ] Failing test written
- [ ] Fix implemented following architecture standards
- [ ] All tests passing
- [ ] Zero linter errors
- [ ] Zero warnings
- [ ] Regression test is permanent and committed

### ğŸ’€ INSTANT FAILURE CONDITIONS:
- Failing tests in codebase
- Linter errors present
- Warnings present
- Modified tests without justification
- Blind fixes without reproduction

**âš°ï¸ PERFECT TESTS OR DEATH! âš°ï¸**
